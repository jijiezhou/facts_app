{"ast":null,"code":"'use strict';\n\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar GetIntrinsic = require('get-intrinsic');\nvar isTypedArray = require('is-typed-array');\nvar $ArrayBuffer = GetIntrinsic('ArrayBuffer', true);\nvar $Float32Array = GetIntrinsic('Float32Array', true);\nvar $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);\n\n// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method\nvar abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;\nvar $abSlice = abSlice && callBind(abSlice);\nmodule.exports = $byteLength || $abSlice ? function isArrayBuffer(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n  try {\n    if ($byteLength) {\n      $byteLength(obj);\n    } else {\n      $abSlice(obj, 0);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n} : $Float32Array\n// in node 0.8, ArrayBuffers have no prototype or own methods\n? function IsArrayBuffer(obj) {\n  try {\n    return new $Float32Array(obj).buffer === obj && !isTypedArray(obj);\n  } catch (e) {\n    return typeof obj === 'object' && e.name === 'RangeError';\n  }\n} : function isArrayBuffer(obj) {\n  // eslint-disable-line no-unused-vars\n  return false;\n};","map":null,"metadata":{},"sourceType":"script"}