{"ast":null,"code":"import _classCallCheck from \"/Users/zj/projects/facts_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/zj/projects/facts_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/zj/projects/facts_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/zj/projects/facts_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/zj/projects/facts_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport PostgrestBuilder from './PostgrestBuilder';\nvar PostgrestTransformBuilder = /*#__PURE__*/function (_PostgrestBuilder) {\n  _inherits(PostgrestTransformBuilder, _PostgrestBuilder);\n  function PostgrestTransformBuilder() {\n    _classCallCheck(this, PostgrestTransformBuilder);\n    return _possibleConstructorReturn(this, _getPrototypeOf(PostgrestTransformBuilder).apply(this, arguments));\n  }\n  _createClass(PostgrestTransformBuilder, [{\n    key: \"select\",\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    value: function select(columns) {\n      // Remove whitespaces except when quoted\n      var quoted = false;\n      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n      if (this.headers['Prefer']) {\n        this.headers['Prefer'] += ',';\n      }\n      this.headers['Prefer'] += 'return=representation';\n      return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order foreign tables, but it doesn't affect the ordering of the\n     * current table.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.foreignTable - Set this to order a foreign table by foreign\n     * columns\n     */\n  }, {\n    key: \"order\",\n    value: function order(column) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$ascending = _ref.ascending,\n        ascending = _ref$ascending === void 0 ? true : _ref$ascending,\n        nullsFirst = _ref.nullsFirst,\n        foreignTable = _ref.foreignTable;\n      var key = foreignTable ? \"\".concat(foreignTable, \".order\") : 'order';\n      var existingOrder = this.url.searchParams.get(key);\n      this.url.searchParams.set(key, \"\".concat(existingOrder ? \"\".concat(existingOrder, \",\") : '').concat(column, \".\").concat(ascending ? 'asc' : 'desc').concat(nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'));\n      return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n  }, {\n    key: \"limit\",\n    value: function limit(count) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        foreignTable = _ref2.foreignTable;\n      var key = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(key, \"\".concat(count));\n      return this;\n    }\n    /**\n     * Limit the query result by starting at an offset (`from`) and ending at the offset (`from + to`).\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n  }, {\n    key: \"range\",\n    value: function range(from, to) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        foreignTable = _ref3.foreignTable;\n      var keyOffset = typeof foreignTable === 'undefined' ? 'offset' : \"\".concat(foreignTable, \".offset\");\n      var keyLimit = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(keyOffset, \"\".concat(from));\n      // Range is inclusive, so add 1\n      this.url.searchParams.set(keyLimit, \"\".concat(to - from + 1));\n      return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n  }, {\n    key: \"abortSignal\",\n    value: function abortSignal(signal) {\n      this.signal = signal;\n      return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n  }, {\n    key: \"single\",\n    value: function single() {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n      return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n  }, {\n    key: \"maybeSingle\",\n    value: function maybeSingle() {\n      // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n      // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n      if (this.method === 'GET') {\n        this.headers['Accept'] = 'application/json';\n      } else {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n      }\n      this.isMaybeSingle = true;\n      return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n  }, {\n    key: \"csv\",\n    value: function csv() {\n      this.headers['Accept'] = 'text/csv';\n      return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n  }, {\n    key: \"geojson\",\n    value: function geojson() {\n      this.headers['Accept'] = 'application/geo+json';\n      return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n  }, {\n    key: \"explain\",\n    value: function explain() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$analyze = _ref4.analyze,\n        analyze = _ref4$analyze === void 0 ? false : _ref4$analyze,\n        _ref4$verbose = _ref4.verbose,\n        verbose = _ref4$verbose === void 0 ? false : _ref4$verbose,\n        _ref4$settings = _ref4.settings,\n        settings = _ref4$settings === void 0 ? false : _ref4$settings,\n        _ref4$buffers = _ref4.buffers,\n        buffers = _ref4$buffers === void 0 ? false : _ref4$buffers,\n        _ref4$wal = _ref4.wal,\n        wal = _ref4$wal === void 0 ? false : _ref4$wal,\n        _ref4$format = _ref4.format,\n        format = _ref4$format === void 0 ? 'text' : _ref4$format;\n      var options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');\n      // An Accept header can carry multiple media types but postgrest-js always sends one\n      var forMediatype = this.headers['Accept'];\n      this.headers['Accept'] = \"application/vnd.pgrst.plan+\".concat(format, \"; for=\\\"\").concat(forMediatype, \"\\\"; options=\").concat(options, \";\");\n      if (format === 'json') return this;else return this;\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var _a;\n      if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {\n        this.headers['Prefer'] += ',tx=rollback';\n      } else {\n        this.headers['Prefer'] = 'tx=rollback';\n      }\n      return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     */\n  }, {\n    key: \"returns\",\n    value: function returns() {\n      return this;\n    }\n  }]);\n  return PostgrestTransformBuilder;\n}(PostgrestBuilder);\nexport { PostgrestTransformBuilder as default };","map":null,"metadata":{},"sourceType":"module"}